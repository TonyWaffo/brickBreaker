#include <SFML/Window.hpp>
#include <SFML/System.hpp>
#include <SFML/Graphics.hpp>
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <chrono>
using namespace std;


class Paddle {
protected:
	sf::RectangleShape rectangle;

private:
	struct coord {
		float x;
		float y;
	};
	coord initPaddlePos;
public:
	sf::Vector2f position;
	Paddle(sf::Vector2f dimension, float posX, float posY) {
		rectangle.setSize(dimension);
		rectangle.setPosition(posX, posY);
		rectangle.setFillColor(sf::Color(90, 150, 50));
		initPaddlePos.x = posX;
		initPaddlePos.y = posY;
	}
	void draw(sf::RenderWindow& window) {
		window.draw(rectangle);
	}

	float getXPosition() {
		return rectangle.getPosition().x;
	}
	float getYPosition() {
		return rectangle.getPosition().y;
	}

	void resetPos() {
		rectangle.setPosition(initPaddlePos.x, initPaddlePos.y);
	}

	void moveLeft() {
		rectangle.move(-25.f, 0.f);
	}
	void moveRight() {
		rectangle.move(25.f, 0.f);
	}

};


// Brick class ineherits from the Paddle class
class Brick :public Paddle {
public:
	bool broken;    // the state of the brick; nice= false, broken=true

	// this line of code is used to inherit the constructor of the Paddle class as well
	Brick(sf::Vector2f dimension, float posX, float posY)
		:Paddle(dimension, posX, posY) {
		rectangle.setFillColor(sf::Color(90, 0, 50));
		broken = false;
	}
};



class Ball {
private:
	sf::CircleShape circle;
	sf::Vector2f velocity;
	sf::Vector2f initBallPos;
public:
	float radius;
	sf::Vector2f position;
	float speedX;
	float speedY;

	Ball(float rad, sf::Vector2f pos):initBallPos(pos) {
		circle.setRadius(rad);
		circle.setPosition(pos);
		circle.setPointCount(100);
		circle.setFillColor(sf::Color(100, 250, 50));
		speedX = 0.50f;
		speedY = -0.50f;
	}

	void draw(sf::RenderWindow& window) {
		window.draw(circle);
	}

	//update the position of the ball according to the speed and the collision
	void update(Paddle& paddle, int width, int height, int& attempt,int& activeGame) {
		position = circle.getPosition();
		radius = circle.getRadius();

		//ball's collision with the top of the window
		if (position.y <= 0) {
			speedY = -speedY;
		}

		//when the ball misses the paddle ( touches the bottom of the window) 
		if ( (position.y + 2 * radius) >= float(height)+100 ) {
			attempt -= 1;					//reduce the number of attempt leading to a gameOver
			cout << attempt << endl;
			activeGame = 0;
			circle.setPosition(initBallPos);      //reposition the ball at the center of the screen 
			paddle.resetPos();
		}

		//ball's collision with the left and right side of the window
		if ((position.x <= 0) || (position.x + 2 * radius) >= float(width)) {
			speedX = -speedX;
		}

		velocity.x = speedX;
		velocity.y = speedY;

		if (attempt > 0) {
			circle.move(velocity);
		}


	}

	float getXballPos() {
		return circle.getPosition().x;
	}
	float getYballPos() {
		return circle.getPosition().y;
	}
};



class Game {
private:
	sf::RenderWindow window;
	sf::Clock clock;
	sf::Clock clock2;

public:
	int width;
	int height;
	int activeGame;   // even number= game off; odd=game on
	int attempt;		//keep in minf you might modify the attempt ==5  at the line 374 if needed

	// :width(w), height(h) is another way to initialise; width=w and height=h
	Game(int w, int h, string name):width(w), height(h) {

		//set the window or the game interface
		window.create(sf::VideoMode(width, height), name, sf::Style::Resize);
		window.setPosition(sf::Vector2i(0, 0));
		activeGame = 0;
		attempt = 5;

	}

	void run() {
		srand(time(0));//it contains the current time as the seed value, so the random number generated by 'rand' will be different on each program execution
		//set the initial position of the ball
		Ball* ball= new Ball(10.f, sf::Vector2f(width / 2.f, (height - (10.f * 2)-30))); //radius and position
		
		//set the paddle at the bottom-middle of the screen

		float paddleWidth = 250.f;
		float paddleHeight = 10.f;
		Paddle paddle(sf::Vector2f(paddleWidth, paddleHeight),width/2.f - 250/2.f, height-20.f);// set the paddle's dimension, and it's position on the x and y axis 
		
		float layerWidth = width - 20.f;
		float layerHeight = 50.f;

		int maxAddNbrLayer = 2;
		int layerNbr = 5 + rand() % (maxAddNbrLayer + 1); // the number of layer is between 5 and 7

		float brickWidth = 160.f;
		float brickHeight = layerHeight;
		int nbrBrick = int(layerWidth) / int(brickWidth);

		vector< vector<Brick> > brick; // multidimensional array. Each row represents a layer and cells represent bricks
		for (int i = 0, y = 10; i < layerNbr; i++, y += layerHeight + 10) {
			brick.push_back(vector<Brick>());  //  this outer loop builds differents layer
			//cout << i << endl;
			for (int j = 0, x = 10; j < nbrBrick; j++, x += brickWidth + 10) {
				brick[i].push_back(Brick(sf::Vector2f(brickWidth, brickHeight), x, y));  //  this inner loop builds differents bricks
			}
		}
		
		
		//run the program as long as the window is open
		while (window.isOpen()) {
			sf::Event event;
			sf::Text text;
			sf::Font font;
			if (!font.loadFromFile("arial.ttf"))   //keep in mind i had to load the .ttf file the directory first
			{
				// error...
			}
			// select the font
			text.setFont(font);
			text.setCharacterSize(40);
			text.setFillColor(sf::Color::White);
			text.setStyle(sf::Text::Bold | sf::Text::Underlined);
			//text.setPosition(200.f, 700.f);

			// handle the interaction with the keyboard
			controller(event,text, window, paddle, paddleWidth);
			sf::Time elapsed = clock.getElapsedTime();
			
			window.clear(sf::Color::Black);
			ball->draw(window);    // draw the ball
			paddle.draw(window);   //draw the padddle


			//draw differents brick on each layers on the screen

			for (int i = 0; i < layerNbr; i++) {
				for (int j = 0; j < nbrBrick; j++) {
					if (brick[i][j].broken == true) {
						continue;
					}
					brick[i][j].draw(window);
				}
			}

			//handle collision between the brick an the ball
			ballBrickCollision(*ball, brick, layerNbr,nbrBrick, brickWidth,brickHeight, width, height);

			//handle collision between the paddle an the ball
			ballPaddleCollision(*ball, paddle, paddleWidth, paddleHeight);


			if (elapsed.asMilliseconds() >= 1 && (activeGame%2 !=0) ) {
				ball->update(paddle, width, height, attempt,activeGame);
				clock.restart();
			} 


			sf::Time elapsed2 = clock2.getElapsedTime();
			Game* game2;

			if (winningGame(brick,layerNbr,nbrBrick)) {
				// enter a big text on the screen when the player won the game
				text.setString("You won the game, another game will start shortly");
				text.setCharacterSize(50);
				text.setFillColor(sf::Color::White);
				text.setStyle(sf::Text::Bold);
				
				if (elapsed2.asSeconds() >= 10) {
					game2 = new Game(1540, 900, "BricK breaker Game");
					delete this;
					game2->run();
				}

			}
			else {
				if (attempt == 0) {
					// enter a big text on the screen when the game is over, retry button
					text.setString("GAME OVER, you can try another party in a few seconds");
					text.setCharacterSize(50);
					text.setFillColor(sf::Color::Red);
					text.setStyle(sf::Text::Bold);
					
					if (elapsed2.asSeconds() >= 10) {
						game2 = new Game(1540, 900, "BricK breaker Game");
						delete this;
						game2->run();
					}
				}
			}

			sf::FloatRect textBounds;
			float xPos;
			float yPos = height - 300.f;
			textBounds = text.getLocalBounds();
			xPos = (width - textBounds.width) / 2.0f;
			text.setPosition(xPos, yPos);

			window.draw(text);
			window.display();
		}
	}

	void ballBrickCollision(Ball& ball,vector<vector<Brick>>& brick, int numLayer, int numBrick, float bkWidth, float bkHeight, int width, int height) {
		float ballX;
		float ballY;

		float brickX;
		float brickY;

		for (int i = 0; i < numLayer; i++) {
			ballY = ball.getYballPos();
			ballX = ball.getXballPos();
			for (int j = 0; j < numBrick; j++) {
				brickX = brick[i][j].getXPosition();
				brickY = brick[i][j].getYPosition();
				//handle collision when the ball comes from any side of the brick

				/*
				
				i 
				have 
				to  handle th e collision when 
				the ball comes from the  4 corners 
				of the bricks
				
				Insert the code right there 
				
				*/
				if (ball.speedY < 0 && ( (ballY + 2*ball.radius) > (brickY + bkHeight) ) ) {		//handle collision when the ball comes from the left side of the brick
					if ( (brick[i][j].broken == false) && (ballY <= (brickY + bkHeight)) && (brickX <= (ballX + ball.radius)) && ((brickX + bkWidth) >= (ballX + ball.radius))) { //maybe ballX+ ball.radius()
						brick[i][j].broken = true;    //(brick[i][j].state == false) &&
						ball.speedY = -ball.speedY; 
					}
				} else if(ball.speedY > 0 && ( ballY  < brickY ) ) { //handle collision when the ball comes from the top of the brick
					if ( (brick[i][j].broken == false) && ((ballY +2* ball.radius) >= (brickY))  && (brickX <= (ballX + ball.radius)) && ((brickX + bkWidth) >= (ballX + ball.radius))) {
						brick[i][j].broken = true;
						ball.speedY = -ball.speedY;
					}
				}
				
				if (ball.speedX < 0 && ( (ballX + 2*ball.radius) > (brickX + bkWidth))) {		//handle collision when the ball comes from the left side of the brick
					if (  (brick[i][j].broken == false) && (ballX <= (brickX + bkWidth)) && ((brickY + bkHeight) >= (ballY +ball.radius)) && (brickY <= (ballY + ball.radius))) { //maybe ballX+ ball.radius()
						brick[i][j].broken = true;
						ball.speedX = -ball.speedX;
					}
				}else if ( ball.speedX > 0 && ( ballX < brickX ) ) {     //handle collision when the ball comes from the right side of the brick
					if (  (brick[i][j].broken == false) && ((ballX + 2*ball.radius) >= brickX) && ((brickY + bkHeight) >= (ballY + ball.radius)) && (brickY <= (ballY + ball.radius))) {
						brick[i][j].broken = true;
						ball.speedX = -ball.speedX;
					}
				}

			}
		} 
		
	}
	void ballPaddleCollision(Ball& ball, Paddle& paddle, float pdWidth, float pdHeight) {
		float ballY = ball.getYballPos();
		float ballX = ball.getXballPos();

		float paddleX = paddle.getXPosition();
		float paddleY = paddle.getYPosition();

		if (ball.speedY > 0 && (ballY < paddleY)) { //handle collision when the ball comes from the top of the paddle
			if ( ((ballY + 2 * ball.radius) >= (paddleY)) && (paddleX <= (ballX + ball.radius)) && ((paddleX + pdWidth) >= (ballX + ball.radius))) {
				ball.speedY = -ball.speedY;
			}
		}

		if (ball.speedX < 0 && ((ballX + 2 * ball.radius) >(paddleX + pdWidth))) {		//handle collision when the ball comes from the left side of paddle brick
			if ( (ballX <= (paddleX + pdWidth)) && ((paddleY + pdHeight) >= (ballY + ball.radius)) && (paddleY <= (ballY + ball.radius))) { //maybe ballX+ ball.radius()
				ball.speedX = -ball.speedX;
			}
		}
		else if (ball.speedX > 0 && (ballX < paddleX)) {     //handle collision when the ball comes from the right side of the paddle
			if ( ((ballX + 2 * ball.radius) >= paddleX) && ((paddleY + pdHeight) >= (ballY + ball.radius)) && (paddleY <= (ballY + ball.radius))) {
				ball.speedX = -ball.speedX;
			}
		}
	}

	void controller(sf::Event& event,sf::Text& text, sf::RenderWindow& window, Paddle& paddle, float pdWidth) {
		sf::FloatRect textBounds;
		float xPos;
		float yPos = height - 300.f;
		if (activeGame == 0) {
			//create a text  on the screen and center it
			if (attempt == 5) {
				text.setString("Press the SPACE button to start the game");
			}
			else {
				text.setString(to_string(attempt) + " remaining chance(s) to win, press the SPACE button to continue");
				text.setStyle(sf::Text::Bold);
			}
			//text.setString("Press the SPACE button to start the game");
			textBounds = text.getLocalBounds();
			xPos = (width - textBounds.width) / 2.0f;  //put the text in the middle horizontally
			text.setPosition(xPos, yPos);
		}
		else if (activeGame != 0 && activeGame % 2 == 0) {

			//create a text  on the screen and center it
			text.setString("The game is paused, click the Space button to resume ");
			textBounds = text.getLocalBounds();
			xPos = (width - textBounds.width) / 2.0f;
			text.setPosition(xPos, yPos);
			text.setStyle(sf::Text::Bold);
		}

		//pending events
		while (window.pollEvent(event)) {
			if (event.type == sf::Event::Closed) {
				window.close();
			}
			else if (event.type == sf::Event::KeyPressed) {
				if (event.key.code == sf::Keyboard::Space) {
					activeGame += 1;
				}
				if (activeGame%2 != 0) {  //behaviours when the game is not on pause
					if (event.key.code == sf::Keyboard::Left)
					{
						if (paddle.getXPosition() > 0)
							paddle.moveLeft();       //move the paddle to the left
					}
					if (event.key.code == sf::Keyboard::Right)
					{
						if (paddle.getXPosition() + pdWidth < width)
							paddle.moveRight();		//move the paddle to the left
					}
				}

			}

		}
	}


	bool winningGame(vector<vector<Brick>>& brick, int numLayer, int numBrick) {
		for (int i = 0; i < numLayer; i++) {
			for (int j = 0; j < numBrick; j++) {

				if (brick[i][j].broken == false) return false;

			}
		}
		return true;
	}


};

int main() {
	// cout << "test" << endl;
	Game* game;

	game = new Game(1540, 900, "BricK breaker Game");
	game->run();
	return 0;
}
